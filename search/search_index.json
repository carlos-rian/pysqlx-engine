{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#pysqlxengine","title":"PySQLXEngine","text":"<p> PySQLXEngine, a fast and minimalist SQL Engine  </p> <p> </p> <p>Documentation: https://carlos-rian.github.io/pysqlx-engine/</p> <p>Source Code: https://github.com/carlos-rian/pysqlx-engine</p> <p>PySQLXEngine supports the option of sending Raw SQL to your database.</p> <p>The PySQLXEngine is a minimalist SQL Engine.</p> <p>The PySQLXEngine was created and thought to be minimalistic, but very efficient. The core is write in Rust, making communication between Databases and Python more efficient.</p> <p>All SQL executed using PySQLXEngine is atomic; only one instruction is executed at a time. Only the first one will be completed if you send an Insert and a select. This is one of the ways to handle SQL ingestion. As of version 0.2.0, PySQLXEngine supports transactions, where you can control <code>BEGIN</code>, <code>COMMIT</code>,  <code>ROLLBACK</code> , <code>ISOLATION LEVEL</code>, etc. as you wish.</p> <p>Note</p> <p>Minimalism is not the lack of something, but having exactly what you need.</p> <p>PySQLXEngine aims to expose an easy interface for you to communicate with the database in a simple, intuitive way and with good help through documentation, autocompletion, typing, and good practices.</p> <p>Database Support:</p> <ul> <li><code>SQLite</code></li> <li><code>PostgreSQL</code></li> <li><code>MySQL</code></li> <li><code>Microsoft SQL Server</code></li> </ul> <p>OS Support:</p> <ul> <li><code>Linux</code></li> <li><code>MacOS</code></li> <li><code>Windows</code></li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"UVPIPPoetry <p>UV</p> <pre><code>$ uv add pysqlx-engine\n\n---&gt; 100%\n</code></pre> <p>PIP</p> <pre><code>$ pip install pysqlx-engine\n\n---&gt; 100%\n</code></pre> <p>Poetry</p> <pre><code>$ poetry add pysqlx-engine\n\n---&gt; 100%\n</code></pre>"},{"location":"index.html#running","title":"Running","text":"<p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    db = PySQLXEngine(uri=\"sqlite:./db.db\")\n    await db.connect()\n\n    await db.execute(sql=\"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY, \n            name TEXT, \n            age INT\n        );\"\"\"\n    )\n\n    sql = \"INSERT INTO users (name, age) VALUES (:n, :a);\"\n    await db.execute(sql=sql, parameters={\"n\": \"Rian\", \"a\": 28})\n    await db.execute(sql=sql, parameters={\"n\": \"Mary\", \"a\": 25})\n\n    rows = await db.query(sql=\"SELECT * FROM users\")\n\n    print(rows)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    db = PySQLXEngineSync(uri=\"sqlite:./db.db\")\n    db.connect()\n\n    db.execute(sql=\"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY, \n            name TEXT, \n            age INT\n        );\"\"\"\n    )\n\n    sql = \"INSERT INTO users (name, age) VALUES (:n, :a);\"\n    db.execute(sql=sql, parameters={\"n\": \"Rian\", \"a\": 28})\n    db.execute(sql=sql, parameters={\"n\": \"Mary\", \"a\": 25})\n\n    rows = db.query(sql=\"SELECT * FROM users\")\n\n    print(rows)\n\n# runnig the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\n[BaseRow(id=1, name='Rian', age=28),  BaseRow(id=2, name='Carlos', age=29)]\n</code></pre>"},{"location":"core_engine.html","title":"Core","text":""},{"location":"core_engine.html#core-engine","title":"Core Engine","text":"<p>PySQLXEngine uses pysqlx-core to perform database queries.  Is an extremely fast Python library for communicating with various SQL databases.</p> <p>pysqlx-core package is written entirely in Rust and compiled as a  Python library using PyO3 and PyO3-Asyncio.</p> <p>This core is not so friendly, but maybe you want to use it, feel free to suggest improvements.</p> <p>As an example, PySQLXEngine connects to the query engine in order to read and write data in a database:</p> <p> </p> PySQLXEngine and pysqlx-core <p>pysqlx-core uses Rust Quaint as the abstraction layer to connect to the database.</p> <p> The PySQLXEngine documentation uses <code>Prisma ORM documentation</code> to specify uri and connectos, as Quaint is the engine underneath Prisma.</p>"},{"location":"databases_and_versions.html","title":"Supported Databases","text":""},{"location":"databases_and_versions.html#databases-and-versions","title":"Databases and versions","text":"<p>Currently supports the following databases:</p> Provider Database Version postgresql PostgreSQL 9.4+, 10, 11, 12, 13, 14 mysql MySQL 5.6, 5.7, 8 mysql MariaDB 10 sqlite SQLite * postgresql AWS Aurora * postgresql AWS Aurora Serverless \u00b9 * sqlserver Microsoft SQL Server 17, 19 sqlserver Azure SQL * <p>An asterisk (*) indicates that the version number is not relevant; either all versions are supported, there is not a public version number, etc.</p> <p>\u00b9 This does not include support for Data API for Aurora Serverless.</p>"},{"location":"type_mappings.html","title":"Type Mappings","text":""},{"location":"type_mappings.html#type-mappings","title":"Type mappings","text":""},{"location":"type_mappings.html#postgresql","title":"PostgreSQL","text":"<p>When introspecting a PostgreSQL database, the database types are mapped to PySQLXEngine according to the following table:</p> PostgreSQL   (Type / Aliases) Python Supported bigint / int8 int \u2714\ufe0f boolean / bool bool \u2714\ufe0f timestamp with time   zone / timestamptz datetime \u2714\ufe0f time without time zone / time time \u2714\ufe0f time with time zone / timetz time \u2714\ufe0f numeric(p,s) / decimal(p,s) decimal \u2714\ufe0f real / float, float4 float \u2714\ufe0f double precision / float8 float \u2714\ufe0f smallint / int2 int \u2714\ufe0f integer / int, int4 int \u2714\ufe0f smallserial / serial2 int \u2714\ufe0f serial / serial4 int \u2714\ufe0f bigserial / serial8 int \u2714\ufe0f character(n) / char(n) str \u2714\ufe0f character   varying(n) / varchar(n) str \u2714\ufe0f money decimal \u2714\ufe0f text str \u2714\ufe0f timestamp datetime \u2714\ufe0f date date \u2714\ufe0f enum str \u2714\ufe0f inet str \u2714\ufe0f bit(n) str \u2714\ufe0f bit varying(n) str \u2714\ufe0f oid int \u2714\ufe0f uuid uuid \u2714\ufe0f json dict/list \u2714\ufe0f jsonb dict/list \u2714\ufe0f bytea bytes \u2714\ufe0f xml str \u2714\ufe0f Array types tuple \u2714\ufe0f citext str \u2714\ufe0f interval Unsupported Not  yet cidr Unsupported Not  yet macaddr Unsupported Not  yet tsvector Unsupported Not  yet tsquery Unsupported Not  yet int4range Unsupported Not  yet int8range Unsupported Not  yet numrange Unsupported Not  yet tsrange Unsupported Not  yet tstzrange Unsupported Not  yet daterange Unsupported Not  yet point Unsupported Not  yet line Unsupported Not  yet lseg Unsupported Not  yet box Unsupported Not  yet path Unsupported Not  yet polygon Unsupported Not  yet circle Unsupported Not  yet Composite   types n/a Not  yet Domain   types n/a Not  yet"},{"location":"type_mappings.html#mysql","title":"MySQL","text":"<p>When introspecting a MySQL database, the database types are mapped to PySQLXEngine according to the following table:</p> MySQL (Type / Aliases) Python Supported serial int \u2714\ufe0f bigint int \u2714\ufe0f bigint unsigned int \u2714\ufe0f bit bytes \u2714\ufe0f boolean | tinyint(1) bool \u2714\ufe0f varbinary bytes \u2714\ufe0f longblob bytes \u2714\ufe0f tinyblob bytes \u2714\ufe0f mediumblob bytes \u2714\ufe0f blob bytes \u2714\ufe0f binary bytes \u2714\ufe0f date datetime \u2714\ufe0f datetime datetime \u2714\ufe0f timestamp datetime \u2714\ufe0f time time \u2714\ufe0f decimal(a,b) decimal \u2714\ufe0f numeric(a,b) decimal \u2714\ufe0f enum str \u2714\ufe0f float float \u2714\ufe0f double float \u2714\ufe0f smallint int \u2714\ufe0f smallint unsigned int \u2714\ufe0f mediumint int \u2714\ufe0f mediumint unsigned int \u2714\ufe0f int int \u2714\ufe0f int unsigned int \u2714\ufe0f tinyint int \u2714\ufe0f tinyint unsigned int \u2714\ufe0f year int \u2714\ufe0f json dict/list \u2714\ufe0f char str \u2714\ufe0f varchar str \u2714\ufe0f tinytext str \u2714\ufe0f text str \u2714\ufe0f mediumtext str \u2714\ufe0f longtext str \u2714\ufe0f set Unsupported Not yet geometry Unsupported Not yet point Unsupported Not yet linestring Unsupported Not yet polygon Unsupported Not yet multipoint Unsupported Not yet multilinestring Unsupported Not yet multipolygon Unsupported Not yet geometrycollection Unsupported Not yet"},{"location":"type_mappings.html#microsoft-sql-server","title":"Microsoft SQL Server","text":"<p>When introspecting a Microsoft SQL Server database, the database types are mapped to PySQLXEngine according to the following table:</p> Microsoft   SQL Server Python Supported char str \u2714\ufe0f nchar str \u2714\ufe0f varchar str \u2714\ufe0f nvarchar str \u2714\ufe0f text str \u2714\ufe0f ntext str \u2714\ufe0f xml str \u2714\ufe0f uniqueidentifier uuid \u2714\ufe0f tinyint bool \u2714\ufe0f bit bool \u2714\ufe0f int int \u2714\ufe0f smallint int \u2714\ufe0f tinyint int \u2714\ufe0f bit int \u2714\ufe0f bigint int \u2714\ufe0f decimal/numeric decimal \u2714\ufe0f money decimal \u2714\ufe0f date date \u2714\ufe0f time time \u2714\ufe0f datetime datetime \u2714\ufe0f datetime2 datetime \u2714\ufe0f smalldatetime datetime \u2714\ufe0f datetimeoffset datetime \u2714\ufe0f binary bytes \u2714\ufe0f varbinary bytes \u2714\ufe0f image bytes \u2714\ufe0f"},{"location":"type_mappings.html#sqlite","title":"SQLite","text":"<p>When introspecting a SQLite database, the database types are mapped to PySQLXEngine according to the following table:</p> SQLite (Type / Aliases) Python Supported TEXT str \u2714\ufe0f BOOLEAN bool \u2714\ufe0f INTEGER int \u2714\ufe0f NUMERIC decimal \u2714\ufe0f REAL float \u2714\ufe0f DECIMAL decimal \u2714\ufe0f BLOB bytes \u2714\ufe0f"},{"location":"advanced_guide/dml_with_return.html","title":"DML With Return","text":""},{"location":"advanced_guide/dml_with_return.html#dml-with-return","title":"DML with return","text":"<p>Although PySQLXEngine has a method for DML <code>execute</code> which returns the number of rows affected.</p> <p>It is possible to use the <code>query*</code> methods to get an output/returning from the database.</p> <p><code>execute</code> always returns the number of rows affected.  Maybe this is not useful, because if you make an <code>insert</code> and want the <code>id</code> as a return, the <code>execute</code> will limit you.</p> <p>Although sql statements are atomic, one execution at a time, most modern databases bring sensational features like <code>RETUNING</code> or <code>OUTPUT</code> in the case of SQL Server that can return a value after the insert .</p> <p>So since we need something to be returned, we can use the <code>query*</code> methods.</p>"},{"location":"advanced_guide/dml_with_return.html#examples","title":"Examples","text":"<p>In this examples we use the <code>user</code> table, which has the structure below.  Change the types to your database types. In this <code>SQLite</code> is used.</p> <pre><code>CREATE TABLE IF NOT EXISTS user (\n    id          INTEGER PRIMARY KEY,\n    first_name  TEXT,\n    last_name   TEXT,\n    created_at  TEXT,\n    updated_at  TEXT\n)\n</code></pre> <p>Warning</p> <p>In this example, MySQL is not mentioned because it does not have reliable support for this type of execution.</p> <p>You can use <code>SELECT LAST_INSERT_ID();</code> after inserting the row, but it is not guaranteed to be the correct ID, given that in a concurrent DB, many inserts at the same time, and the <code>LAST_INSERT_ID()</code> function takes only the last one. If possible, start using MariaDB; in addition to being more reliable, it is also an up-to-date open source.</p>"},{"location":"advanced_guide/dml_with_return.html#postgresql-sqlite-and-mariadb","title":"PostgreSQL, SQLite and MariaDB","text":"<p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngine(uri=uri)\n\nasync def main():\n    await db.connect()\n\n    sql = \"\"\"sql\n        INSERT INTO user (\n            first_name, \n            last_name, \n            created_at, \n            updated_at) \n        VALUES (\n            'bob', \n            'test', \n            '2022-05-30 05:47:51', \n            '2022-05-30 05:47:51'\n        )\n        RETURNING id;\n    \"\"\"\n\n    row = await db.query(sql=sql)\n    print(row)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngineSync(uri=uri)\n\ndef main():\n    db.connect()\n\n    sql = \"\"\"sql\n        INSERT INTO user (\n            first_name, \n            last_name, \n            created_at, \n            updated_at) \n        VALUES (\n            'bob', \n            'test', \n            '2022-05-30 05:47:51', \n            '2022-05-30 05:47:51'\n        )\n        RETURNING id;\n    \"\"\"\n\n    row = db.query(sql=sql)\n    print(row)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\n[BaseRow(id=1)]\n</code></pre>"},{"location":"advanced_guide/dml_with_return.html#microsoft-sql-server","title":"Microsoft SQL Server","text":"<p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngine(uri=uri)\n\nasync def main():\n    await db.connect()\n\n    sql = \"\"\"sql\n        INSERT INTO user (\n            first_name, \n            last_name, \n            created_at, \n            updated_at)\n        OUTPUT Inserted.id\n        VALUES (\n            'bob', \n            'test', \n            '2022-05-30 05:47:51', \n            '2022-05-30 05:47:51'\n        );\n    \"\"\"\n\n    row = await db.query(sql=sql)\n    print(row)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngineSync(uri=uri)\n\ndef main():\n    db.connect()\n\n    sql = \"\"\"sql\n        INSERT INTO user (\n            first_name, \n            last_name, \n            created_at, \n            updated_at)\n        OUTPUT Inserted.id\n        VALUES (\n            'bob', \n            'test', \n            '2022-05-30 05:47:51', \n            '2022-05-30 05:47:51'\n        );\n    \"\"\"\n\n    row = db.query(sql=sql)\n    print(row)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\n[BaseRow(id=1)]\n</code></pre>"},{"location":"advanced_guide/json_support.html","title":"JSON Support","text":""},{"location":"advanced_guide/json_support.html#json-support","title":"JSON Support","text":"<p>PySQLX-Engine has support for converting various types to JSON dumps. This dump is accepted into your database as a string.</p> <p>Some databases have native support for JSON, but some don't. When you send a <code>parameter</code> of type <code>list</code> or <code>dict</code> to the database,  PySQLX-Engine will convert it into a JSON dump and send it to the database as a string.</p>"},{"location":"advanced_guide/json_support.html#json-encoding-types","title":"JSON Encoding Types","text":"Python Types JSON Types IN OUT bytes String(Hex) b'super bytes' \"7375706572206279746573\" uuid String UUID('ae77f0f3-0313-4ebe-9d1f-319d8fbe94d6') \"ae77f0f3-0313-4ebe-9d1f-319d8fbe94d6\" time String datetime.time(12, 20, 50) \"12:20:50\" date String datetime.date(2023, 1, 15) \"2023-01-15\" datetime String datetime.datetime(2023, 1, 15, 16, 7, 1, 441234) \"2023-01-15 16:07:01.441234\" Decimal String Decimal('1.23') '1.23' None Null None null bool Bool True true str String 'value' \"value\" int Int 123 123 float Float 32.33 32.33 * Try converting using standard <code>JSON Dumps</code>"},{"location":"advanced_guide/json_support.html#example","title":"Example","text":"AsyncSync main.py<pre><code>import datetime\nfrom uuid import UUID\nfrom decimal import Decimal\n\nfrom pysqlx_engine import PySQLXEngine\n\nasync def main():\n    db = PySQLXEngine(uri=\"postgresql://user:pass@host:port/db\")\n    await db.connect()\n\n    data = {\n        \"json\":{\n            \"id\": 1,\n            \"name\": \"John\",\n            \"age\": 20,\n            \"data\": {\n                \"a\": 1,\n                \"b\": 2,\n                \"c\": 3,\n            },\n            \"list\": [1, 2, 3],\n            \"bytes\": b\"super bytes\",\n            \"uuid\": UUID('ae77f0f3-0313-4ebe-9d1f-319d8fbe94d6'),\n            \"time\": datetime.time(12, 20, 50),\n            \"date\": datetime.date(2023, 1, 15),\n            \"datetime\": datetime.datetime(2023, 1, 15, 16, 7, 1, 441234),\n            \"decimal\": Decimal('1.23'),\n            \"none\": None,\n            \"bool\": True,\n        }\n    }\n\n    resp = await db.query_first(sql=\"SELECT :json AS json_value\", parameters=data)\n\n    print(resp)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>import datetime\nfrom uuid import UUID\nfrom decimal import Decimal\n\nfrom pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    db = PySQLXEngineSync(uri=\"postgresql://user:pass@host:port/db\")\n    db.connect()\n\n    data = {\n        \"json\":{\n            \"id\": 1,\n            \"name\": \"John\",\n            \"age\": 20,\n            \"data\": {\n                \"a\": 1,\n                \"b\": 2,\n                \"c\": 3,\n            },\n            \"list\": [1, 2, 3],\n            \"bytes\": b\"super bytes\",\n            \"uuid\": UUID('ae77f0f3-0313-4ebe-9d1f-319d8fbe94d6'),\n            \"time\": datetime.time(12, 20, 50),\n            \"date\": datetime.date(2023, 1, 15),\n            \"datetime\": datetime.datetime(2023, 1, 15, 16, 7, 1, 441234),\n            \"decimal\": Decimal('1.23'),\n            \"none\": None,\n            \"bool\": True,\n        }\n    }\n\n    resp = db.query_first(sql=\"SELECT :json AS json_value\", parameters=data)\n\n    print(resp)\n\n# running the code\nmain()\n</code></pre>"},{"location":"advanced_guide/json_support.html#running-the-code","title":"Running the code","text":"<p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n</code></pre> <p>Output</p> python print<pre><code>BaseRow(json='{\n    \"id\": 1, \n    \"name\": \"John\", \n    \"age\": 20, \n    \"data\": {\n        \"a\": 1, \n        \"b\": 2, \n        \"c\": 3\n    }, \n    \"list\": [1, 2, 3], \n    \"bytes\": \"7375706572206279746573\", \n    \"uuid\": \"ae77f0f3-0313-4ebe-9d1f-319d8fbe94d6\", \n    \"time\": \"12:20:50\", \n    \"date\": \"2023-01-15\", \n    \"datetime\": \"2023-01-15 16:07:01.441234\", \n    \"decimal\": \"1.23\", \n    \"none\": null, \n    \"bool\": true\n    }'\n)\n</code></pre>"},{"location":"advanced_guide/pool.html","title":"Create a Pool with Concurrent Connections","text":""},{"location":"advanced_guide/pool.html#create-a-pool-with-concurrent-connections","title":"Create a pool with concurrent connections","text":"<p>The PySQLXEngine allows you to create a pool of connections to the database.  You can reuse and recycle connections to the database, which can improve the performance of your application.</p> <p>This example will use the <code>SQLite</code> database.</p>"},{"location":"advanced_guide/pool.html#introduction","title":"Introduction","text":"<p>The PySQLXEngine provides two types of pools: <code>PySQLXEnginePool</code> for asynchronous connections and <code>PySQLXEnginePoolSync</code> for synchronous connections.</p> <p>Both work similarly, but the asynchronous pool is designed to work with <code>asyncio</code> and the synchronous pool with threads.</p> <p>Parameters</p> <ul> <li><code>uri: str</code>: Database URI, e.g. <code>sqlite:./dev.db</code></li> <li><code>min_size: int</code>: Minimum number of connections in the pool, you can start the pool with the minimum number of connections</li> <li><code>max_size: int</code>: (default: 10): Maximum number of connections in the pool</li> <li><code>conn_timeout: float</code>: (default: 30.0) Connection timeout in seconds, waiting for a connection to be available, case the timeout is reached, a <code>PoolTimeoutError</code> is raised</li> <li><code>keep_alive: float</code>: (default: 60 * 15) Time to keep the connection alive in the pool</li> <li><code>check_interval: float</code>: (default: 5.0) Interval to check the connections in the pool</li> <li><code>monitor_batch_size: int</code>: (default: 10)  Number of connections to check per interval</li> </ul> <p>Easily create a pool of connections and start reusing them in your application.</p>"},{"location":"advanced_guide/pool.html#simple-example","title":"Simple example","text":"<p>Creating and starting the pool</p> AsyncSync main.py<pre><code>import asyncio\nfrom pysqlx_engine import PySQLXEnginePool\n\nasync def main():\n    pool = PySQLXEnginePool(uri=\"sqlite:./dev.db\", min_size=5)\n    await pool.start() # Start the pool\n\nasyncio.run(main())\n</code></pre> main.py<pre><code># import\nfrom pysqlx_engine import PySQLXEnginePoolSync\n\ndef main():\n    pool = PySQLXEnginePoolSync(uri=\"sqlite:./dev.db\", min_size=5)\n    pool.start() # Start the pool\n\nmain()\n</code></pre> <p>Taking a connection from the pool</p> AsyncSync main.py<pre><code>import asyncio\nfrom pysqlx_engine import PySQLXEnginePool\n\nasync def main():\n    pool = PySQLXEnginePool(uri=\"sqlite:./dev.db\", min_size=5)\n    await pool.start() # Start the pool\n\n    async with pool.connection() as conn:\n        # Use the connection\n        resp = await conn.query_first(\"SELECT 1 as a\")\n        print(resp) # Output: BaseRow(a=1)\n\nasyncio.run(main())\n</code></pre> main.py<pre><code># import\nfrom pysqlx_engine import PySQLXEnginePoolSync\n\ndef main():\n    pool = PySQLXEnginePoolSync(uri=\"sqlite:./dev.db\", min_size=5)\n    pool.start() # Start the pool\n\n    with pool.connection() as conn:\n        # Use the connection\n        resp = conn.query_first(\"SELECT 1 as a\")\n        print(resp) # Output: BaseRow(a=1)\n\nmain()\n</code></pre> <p>Stopping the pool</p> AsyncSync main.py<pre><code>import asyncio\nfrom pysqlx_engine import PySQLXEnginePool\n\nasync def main():\n    pool = PySQLXEnginePool(uri=\"sqlite:./dev.db\", min_size=5)\n    await pool.start() # Start the pool\n\n    # Use the pool\n\n    await pool.stop() # Stop the pool\n\nasyncio.run(main())\n</code></pre> main.py<pre><code># import\nfrom pysqlx_engine import PySQLXEnginePoolSync\n\ndef main():\n    pool = PySQLXEnginePoolSync(uri=\"sqlite:./dev.db\", min_size=5)\n    pool.start() # Start the pool\n\n    # Use the pool\n\n    pool.stop() # Stop the pool\n\nmain()\n</code></pre> <p>Complete example</p> AsyncSync main.py<pre><code>import asyncio\nfrom pysqlx_engine import PySQLXEnginePool\n\nasync def main():\n    pool = PySQLXEnginePool(uri=\"sqlite:./dev.db\", min_size=5)\n    await pool.start() # Start the pool\n\n    async with pool.connection() as conn:\n        # Use the connection\n        resp = await conn.query_first(\"SELECT 1 as a\")\n        print(resp) # Output: BaseRow(a=1)\n\n    await pool.stop() # Stop the pool\n\nasyncio.run(main())\n</code></pre> main.py<pre><code># import\nfrom pysqlx_engine import PySQLXEnginePoolSync\n\ndef main():\n    pool = PySQLXEnginePoolSync(uri=\"sqlite:./dev.db\", min_size=5)\n    pool.start() # Start the pool\n\n    with pool.connection() as conn:\n        # Use the connection\n        resp = conn.query_first(\"SELECT 1 as a\")\n        print(resp) # Output: BaseRow(a=1)\n\n    pool.stop() # Stop the pool\n\nmain()\n</code></pre>"},{"location":"advanced_guide/pool.html#concurrent-connections-example","title":"Concurrent connections example","text":"<p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>import asyncio\nimport logging\nimport random\nimport time\n\nfrom pysqlx_engine import PySQLXEnginePool, LOG_CONFIG\n\nLOG_CONFIG.PYSQLX_DEV_MODE = True\nLOG_CONFIG.PYSQLX_SQL_LOG = True\nLOG_CONFIG.PYSQLX_USE_COLOR = True\nLOG_CONFIG.PYSQLX_ERROR_JSON_FMT = True\n\nlogging.basicConfig(level=logging.DEBUG)\n\nMAX_CONCURRENT_WORKERS = 50\nsemaphore = asyncio.Semaphore(MAX_CONCURRENT_WORKERS)\n\n\nasync def simulate_work_async(pool: PySQLXEnginePool):\n    async with semaphore:  # Limit the number of simultaneous workers\n        try:\n            async with pool.connection() as conn:\n                # Simulate some async work\n                resp = await conn.query_first(\"SELECT 1 as a\")\n                assert resp.a == 1\n                await asyncio.sleep(random.uniform(0.1, 0.5))\n        except Exception as e:\n            logging.error(f\"Error occurred: {e}\")\n\n\nasync def stress_test_async_pool(pool, num_requests=1000):\n    tasks = [simulate_work_async(pool) for _ in range(num_requests)]\n    await asyncio.gather(*tasks)\n\n\nif __name__ == \"__main__\":\n    start = time.monotonic()\n\n    async def main():\n        # Initialize your async pool here\n        pool = PySQLXEnginePool(\n            uri=\"sqlite:./dev.db\", min_size=5, max_size=30, conn_timeout=60, check_interval=0.5\n        )  # Adjust parameters as needed\n        await pool.start()  # Ensure to start the pool if there's such a method\n        await stress_test_async_pool(pool)\n        await pool.stop()  # Properly close the pool after testing\n\n    asyncio.run(main())\n    end = time.monotonic()\n    logging.info(f\"Time taken: {end - start:.2f} seconds\")\n</code></pre> main.py<pre><code>import concurrent.futures\nimport logging\nimport random\nimport time\n\nfrom pysqlx_engine import PySQLXEnginePoolSync, LOG_CONFIG\n\nLOG_CONFIG.PYSQLX_DEV_MODE = True\nLOG_CONFIG.PYSQLX_SQL_LOG = True\nLOG_CONFIG.PYSQLX_USE_COLOR = True\nLOG_CONFIG.PYSQLX_ERROR_JSON_FMT = True\n\nlogging.basicConfig(level=logging.DEBUG)\n\nMAX_CONCURRENT_WORKERS = 50\n#\n\n\ndef simulate_work(pool: PySQLXEnginePoolSync):\n    try:\n        with pool.connection() as conn:\n            # Simulate some work with the connection\n            resp = conn.query_first(\"SELECT 1 as a\")\n            assert resp.a == 1\n            time.sleep(random.uniform(0.1, 0.5))\n    except Exception as e:\n        logging.error(f\"Error occurred: {e}\")\n\n\ndef stress_test_sync_pool(pool, num_requests=1000):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_CONCURRENT_WORKERS) as executor:\n        # Submit multiple tasks to simulate concurrent connections\n        futures = [executor.submit(simulate_work, pool) for _ in range(num_requests)]\n        concurrent.futures.wait(futures)\n\n\nif __name__ == \"__main__\":\n    # Initialize your pool here\n    start = time.monotonic()\n    pool = PySQLXEnginePoolSync(\n        uri=\"sqlite:./dev.db\", min_size=5, max_size=30, conn_timeout=60, check_interval=0.5\n    )  # Adjust parameters as needed\n    pool.start()\n    stress_test_sync_pool(pool)\n    pool.stop()\n    end = time.monotonic()\n    logging.info(f\"Time taken: {end - start:.2f} seconds\")\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n...\n\nINFO:pysqlx_engine:Pool: Starting the connection pool.\nDEBUG:pysqlx_engine:Pool: New connection created: &lt;pysqlx_engine._core.apool.ConnInfo 'conn-1' at 0x7f24301e78c0&gt; PoolSize: 1\n...\nINFO:pysqlx_engine:Pool: Initialized with 5 connections.\nDEBUG:pysqlx_engine:Worker: Worker-1-ConnectionMonitor starting.\nINFO:pysqlx_engine:Pool: Workers started.\nDEBUG:pysqlx_engine:Async -&gt; Starting task: ConnectionMonitor\nDEBUG:pysqlx_engine:Async -&gt; Running task: ConnectionMonitor\nINFO:pysqlx_engine:Monitor: Started monitoring the pool.\n...\nDEBUG:pysqlx_engine:Getting a ready connection.\nDEBUG:pysqlx_engine:Acquired semaphore in 0.00001 seconds\nDEBUG:pysqlx_engine:Pool: Growing: False Waiting: 1\nDEBUG:pysqlx_engine:Pool: Connection: &lt;pysqlx_engine._core.apool.ConnInfo 'conn-1' at 0x7f24301e78c0&gt; retrieved in 0.00018 seconds.\nDEBUG:pysqlx_engine:Pool: Growing: False Waiting: 0\nDEBUG:pysqlx_engine:Pool: Connection returned to pool: &lt;pysqlx_engine._core.apool.ConnInfo 'conn-1' at 0x7f24301e78c0&gt;\n...\nDEBUG:pysqlx_engine:Pool: Connection returned to pool: &lt;pysqlx_engine._core.apool.ConnInfo 'conn-1' at 0x7f24301e78c0&gt;\n...\nINFO:pysqlx_engine:Pool: Stopping the connection pool.\nINFO:pysqlx_engine:Removed: &lt;pysqlx_engine._core.apool.ConnInfo 'conn-1' at 0x7f24301e78c0&gt; from pool, the conn was open for 5.36555 secs\n...\nDEBUG:pysqlx_engine:Worker: Worker-1-ConnectionMonitor finishing.\nINFO:pysqlx_engine:Monitor: Stopped monitoring the pool.\nDEBUG:pysqlx_engine:Async -&gt; Stopping task: ConnectionMonitor\nINFO:pysqlx_engine:Pool: All workers stopped and connections closed.\n</code></pre>"},{"location":"user_guide/index.html","title":"Introduction","text":""},{"location":"user_guide/index.html#introduction","title":"Introduction","text":"<p>The PySQLXEngine is a library that allows you to connect to a database and execute queries in a simple way.</p> <p>So you can use it to create, read, update and delete data in your database.</p> <p>Since the beginning PySQLXEngine was created and thinking to be a totally <code>async</code> engine.  Although Python has supported asynchronous programming since version <code>3.5*</code> using <code>async/await</code>. We currently don't have good <code>async</code> libraries to handle SQL Server asynchronously, for example.</p> <p>Despite being designed to be <code>async</code>, PySQLXEngine has sync support as well. The classes <code>PySQLXEngine</code> and <code>PySQLXEngineSync</code> are made available.</p> <p>Both <code>async</code> and <code>sync</code> classes have precisely the same methods.</p>"},{"location":"user_guide/index.html#providersdrivers","title":"Providers/Drivers","text":"<ul> <li><code>sqlite</code></li> <li><code>postgresql</code></li> <li><code>mysql</code></li> <li><code>sqlserver</code></li> </ul>"},{"location":"user_guide/index.html#uris","title":"URIs","text":"<ul> <li><code>sqlite</code></li> </ul> <pre><code>uri = \"sqlite:./dev.db\"\n</code></pre> <ul> <li><code>postgresql</code></li> </ul> <pre><code>uri = \"postgresql://user:pass@host:port/db?schema=sample\"\n</code></pre> <ul> <li><code>mysql</code></li> </ul> <pre><code>uri = \"mysql://user:pass@host:port/db?schema=sample\"\n</code></pre> <ul> <li><code>sqlserver</code></li> </ul> <pre><code>uri = \"sqlserver://host:port;initial catalog=sample;user=sa;password=pass;\"\n</code></pre>"},{"location":"user_guide/index.html#example-of-use-async-and-sync","title":"Example of use async and sync","text":"<p>In a way, the code's only change would be the word <code>async/await</code>.</p> <p>Asynchronous programming is a broad subject, but our tutorial is intended to be objective. So, in summary,  when you need a performance in the sense of doing concurrency \"at the same time\", use <code>async</code>.  You can use the sync form something need to do things that don't need concurrency.</p>"},{"location":"user_guide/index.html#create-the-file","title":"Create the file","text":"<p>Create a file called <code>main.py</code> and add the code below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main(): # need to be async, because of await\n    db = PySQLXEngine(uri=\"sqlite:./db.db\")\n    await db.connect() # need to await\n    print(\"Connected: \", db.connected)\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main(): # don't need to be async\n    db = PySQLXEngineSync(uri=\"sqlite:./db.db\")\n    db.connect() # don't need to await\n    print(\"Connected: \", db.connected)\n</code></pre>"},{"location":"user_guide/index.html#calling-the-functions","title":"Calling the functions","text":"<p>To call the coroutine functions, you need to use the <code>asyncio</code> library, this library is part of the standard library of Python.</p> <p>So, you need to add the below lines at the end of your code!</p> AsyncSync main.py<pre><code>...# your code\n\nimport asyncio # need to import \nasyncio.run(main()) # call the function\n</code></pre> main.py<pre><code>...# your code\n\n# don't need to import asyncio\nmain() # call the function\n</code></pre>"},{"location":"user_guide/index.html#running-the-code","title":"Running the code","text":"<p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nConnected: True\n</code></pre>"},{"location":"user_guide/config.html","title":"Configs","text":""},{"location":"user_guide/config.html#config","title":"Config","text":"<p>PySQLXEngine has some settings that can help the developer identify problems and have a better experience when dealing with the application's logs and errors.</p> <p>You can configure these settings using environment variables or <code>LOG_CONFIG</code> const to change logs and errors.</p>"},{"location":"user_guide/config.html#keyword","title":"Keyword","text":"<ul> <li><code>PYSQLX_DEV_MODE</code>: default(<code>False</code>) If <code>True</code>, the PySQLXEngine will be in development mode. In this mode, will show the SQL statements builded with the parameters. (Just for development, the SQL is not sent to the database).</li> <li><code>PYSQLX_SQL_LOG</code>: default(<code>False</code>) If <code>True</code>, the SQL statements will be printed in the console. This log is available at the <code>INFO</code> level of the <code>logging</code>.</li> <li><code>PYSQLX_USE_COLOR</code>: default(<code>False</code>) If <code>True</code>, the messages will be printed in color.</li> <li><code>PYSQLX_ERROR_JSON_FMT</code>: default(<code>False</code>) If <code>True</code>, the error messages will be printed in JSON format.</li> </ul>"},{"location":"user_guide/config.html#set-environment-variables","title":"Set environment variables","text":"LinuxWindows <pre><code>export PYSQLX_DEV_MODE=1\nexport PYSQLX_SQL_LOG=1\nexport PYSQLX_USE_COLOR=1\nexport PYSQLX_ERROR_JSON_FMT=1\n</code></pre> <pre><code>set PYSQLX_DEV_MODE=1\nset PYSQLX_SQL_LOG=1\nset PYSQLX_USE_COLOR=1\nset PYSQLX_ERROR_JSON_FMT=1\n</code></pre>"},{"location":"user_guide/config.html#set-log_config-const","title":"Set LOG_CONFIG const","text":"<pre><code>from pysqlx_engine import LOG_CONFIG\n\nLOG_CONFIG.PYSQLX_DEV_MODE = True\nLOG_CONFIG.PYSQLX_SQL_LOG = True\nLOG_CONFIG.PYSQLX_USE_COLOR = True\nLOG_CONFIG.PYSQLX_ERROR_JSON_FMT = True\n</code></pre>"},{"location":"user_guide/config.html#config-the-logger","title":"Config the logger","text":"<p>After setting the environment variables or <code>LOG_CONFIG</code> const, you can configure the logger as you wish.</p> <p>The PySQLXEngine logger is available at root logger.</p> Environment variablesLOG_CONFIG const main.py<pre><code>import logging\nfrom pysqlx_engine import PySQLXEngineSync\n\n# set the logger level to INFO\nlogging.basicConfig(level=logging.INFO)\n\n# connect to the database\ndb = PySQLXEngineSync(uri=\"postgresql://user:pass@host:port/db\")\ndb.connect()\n\n# run the query and see the log\ndb.query(\"SELECT * FROM valid_table\") # change the 'valid_table' \ndb.query(\"SELECT * FROM invalid_table\")\n</code></pre> main.py<pre><code>import logging\nfrom pysqlx_engine import PySQLXEngineSync, LOG_CONFIG\n\nLOG_CONFIG.PYSQLX_DEV_MODE = True\nLOG_CONFIG.PYSQLX_SQL_LOG = True\nLOG_CONFIG.PYSQLX_USE_COLOR = True\nLOG_CONFIG.PYSQLX_ERROR_JSON_FMT = True\n\n# set the logger level to INFO\nlogging.basicConfig(level=logging.INFO)\n\n# connect to the database\ndb = PySQLXEngineSync(uri=\"postgresql://user:pass@host:port/db\")\ndb.connect()\n\n# run the query and see the log\ndb.query(\"SELECT * FROM valid_table\") # change the 'valid_table'\ndb.query(\"SELECT * FROM invalid_table\")\n</code></pre>"},{"location":"user_guide/config.html#running-the-code","title":"Running the code","text":"<p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n</code></pre> <p>Output</p> SQL log<pre><code>INFO:root:SELECT * FROM valid_table\nINFO:root:SELECT * FROM invalid_table\n</code></pre> Error log<pre><code>pysqlx_engine._core.errors.QueryError: \n{\n    \"code\": \"42P01\",\n    \"message\": \"relation 'invalid_table' does not exist\",\n    \"error\": \"QueryError\"\n}\n</code></pre>"},{"location":"user_guide/examples.html","title":"Examples","text":""},{"location":"user_guide/examples.html#next-steps","title":"Next steps","text":"<p>This section provides some next steps for you to continue learning about PySQLXEngine.</p> <p>PySQLXEngine has some methods; among them, the <code>query</code> and <code>execute</code> methods are handy.</p> <p>The methods <code>.query*</code> is used to execute a query that returns data, and <code>.execute</code> is used to run a query that does not return data but only the number of rows affected.</p> <p>Both methods have the two parameters:</p> <ul> <li><code>sql</code>: The SQL query to be executed.</li> <li><code>parameters</code>: The parameters to be passed to the query. This parameter is optional.</li> </ul> <p>Note</p> <p>SQL must be a str with or without named parameters.</p> <p>Note</p> <p>Parameters must be a dictionary with the named parameters and their values.</p>"},{"location":"user_guide/examples.html#example-of-use","title":"Example of use","text":"<p>For this example, we will use the <code>sqlite</code> database. Create a <code>main.py</code> file and add the code examples below.</p>"},{"location":"user_guide/examples.html#create-a-table","title":"Create a table","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY, \n            name TEXT, \n            age INTEGER\n        );\n    \"\"\"\n\n    resp = await db.execute(sql=sql)\n\n    print(\"table created: \", resp == 0)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY, \n            name TEXT, \n            age INTEGER\n        );\n    \"\"\"\n\n    resp = db.execute(sql=sql)\n\n    print(\"table created: \", resp == 0)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\ntable created: True\n</code></pre>"},{"location":"user_guide/examples.html#insert-data","title":"Insert data","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"INSERT INTO users (name, age) VALUES (:name, :age)\"\n    params = {\"name\": \"John\", \"age\": 20}\n    resp = await db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"INSERT INTO users (name, age) VALUES (:name, :age)\"\n    params = {\"name\": \"John\", \"age\": 20}\n    resp = db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nrows affected: 1\n</code></pre>"},{"location":"user_guide/examples.html#select-data","title":"Select data","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"SELECT * FROM users\"\n    resp = await db.query(sql=sql)\n\n    print(\"rows selected: \", resp)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"SELECT * FROM users\"\n    resp = db.query(sql=sql)\n\n    print(\"rows selected: \", resp)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nrows selected: [BaseRow(id=1, name='John', age=20)]\n</code></pre>"},{"location":"user_guide/examples.html#update-data","title":"Update data","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"UPDATE users SET age = :age WHERE id = :id\"\n    params = {\"age\": 21, \"id\": 1}\n    resp = await db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"UPDATE users SET age = :age WHERE id = :id\"\n    params = {\"age\": 21, \"id\": 1}\n    resp = db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nrows affected: 1\n</code></pre>"},{"location":"user_guide/examples.html#delete-data","title":"Delete data","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"DELETE FROM users WHERE id = :id\"\n    params = {\"id\": 1}\n    resp = await db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"DELETE FROM users WHERE id = :id\"\n    params = {\"id\": 1}\n    resp = db.execute(sql=sql, parameters=params)\n\n    print(\"rows affected: \", resp)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nrows affected: 1\n</code></pre>"},{"location":"user_guide/examples.html#drop-table","title":"Drop table","text":"AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"DROP TABLE users\"\n    resp = await db.execute(sql=sql)\n\n    print(\"table dropped: \", resp == 0)\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"DROP TABLE users\"\n    resp = db.execute(sql=sql)\n\n    print(\"table dropped: \", resp == 0)\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\ntable dropped: True\n</code></pre>"},{"location":"user_guide/extras.html","title":"Documentation for Methods","text":""},{"location":"user_guide/extras.html#more-documentation","title":"More documentation","text":"<p>The PySQLXEngine has more some methods to you can use the database more easily. See the documentation below:</p> <ul> <li> <p><code>.connect()</code> create connection with db.</p> </li> <li> <p><code>.close()</code> disconnected from db.</p> </li> <li> <p><code>.is_healthy()</code> check if the connection is healthy.</p> </li> <li> <p><code>.requires_isolation_first()</code> this is used to determine if the connection should be isolated before executing a sql.</p> </li> <li> <p><code>.raw_cmd()</code> run a command in the database, for queries that can't be run using prepared statements.</p> </li> <li> <p><code>.query*()</code> to return actual records (for example, using SELECT).</p> </li> <li> <p><code>.execute()</code> to return a count of affected rows (for example, after an INSERT, UPDATE or DELETE).</p> </li> <li> <p><code>.set_isolation_level()</code> the isolation level is set before the transaction is started. Is used to separate the transaction per level.</p> </li> <li> <p><code>.begin()</code> starts a transaction.</p> </li> <li> <p><code>.commit()</code> commits a transaction.</p> </li> <li> <p><code>.rollback()</code> rollbacks a transaction.</p> </li> <li> <p><code>.start_transaction()</code> starts a transaction with BEGIN/BEGIN TRANSACTION. By default, does not set the isolation level. But is possible to set the isolation level using the parameter <code>isolation_level</code>.</p> </li> </ul>"},{"location":"user_guide/extras.html#parameters-helper","title":"Parameters Helper","text":"<p>The PySQLXEngine has five methods that accept the parameters with sql.</p> <p>Parameters are passed to the database with the SQL query.</p> <p>The parameters are used to avoid SQL injection and to make the code more secure.</p>"},{"location":"user_guide/extras.html#sql-with-parameters-syntax","title":"SQL with parameters syntax","text":"<ul> <li>SQL</li> </ul> <pre><code>SELECT * FROM table WHERE id = :id\n</code></pre> <ul> <li>Parameters</li> </ul> <pre><code>{\"id\": 1}\n</code></pre>"},{"location":"user_guide/extras.html#parameters","title":"Parameters","text":"<ul> <li>dict <code>key</code> must be a valid string.</li> <li>dict <code>value</code> can be one of the types:<ul> <li><code>bool</code></li> <li><code>bytes</code></li> <li><code>date</code></li> <li><code>datetime</code></li> <li><code>Decimal</code></li> <li><code>dict</code></li> <li><code>float</code></li> <li><code>int</code></li> <li><code>list</code></li> <li><code>str</code></li> <li><code>time</code></li> <li><code>tuple</code></li> <li><code>UUID</code></li> <li><code>None</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#python-types-vs-sql-types","title":"Python types vs SQL types","text":"Python Databases bool bool/bit/boolean/tinyint/etc. bytes bytea/binary/varbinary/blob/etc. date date/nvarchar/varchar/string/etc. datetime timestamp/timestamptz/datetime/datetime2/nvarchar/varchar/string/etc. Decimal decimal/numeric/etc. dict json/jsonb/nvarchar/varchar/string/etc. float float/real/numeric/etc. int int/integer/smallint/bigint/tinyint/etc. list json/jsonb/nvarchar/varchar/string/etc. str varchar/text/nvarchar/char/etc. time time/nvarchar/varchar/string/etc. tuple array(Postgres Native), error for other databases. UUID uuid/varchar/text/nvarchar/etc. None null."},{"location":"user_guide/extras.html#methods","title":"Methods","text":""},{"location":"user_guide/extras.html#connect","title":"connect","text":""},{"location":"user_guide/extras.html#description","title":"Description","text":"<p>Each connection instance is lazy; only after <code>.connect()</code> is the database checked and the connection established.</p> <p>When you use <code>with/async with</code>  the connection is automatically opened and closed.</p> <p>Example</p> <p><code>PySQLXEngine</code> also supports <code>with/async with</code>, where the connection is automatically opened and closed.</p> AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"sqlite:./db.db\"\n\nasync def main():\n    async with PySQLXEngine(uri=uri) as db:\n        ...\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"sqlite:./db.db\"\n\ndef main():\n    with PySQLXEngineSync(uri=uri) as db:\n        ...\n</code></pre>"},{"location":"user_guide/extras.html#helper","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: <code>ConnectError</code></p> </li> </ul>"},{"location":"user_guide/extras.html#example","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\nuri = \"sqlite:./db.db\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n</code></pre>"},{"location":"user_guide/extras.html#close","title":"close","text":""},{"location":"user_guide/extras.html#description_1","title":"Description","text":"<p>It's a good idea to close the connection, but PySQLXEngine has the core in Rust; closing is automatic when your code leaves the context.</p> <p>Even if you don't close the connection, don't worry; when the process ends automatically, the connections will be closed, so the database doesn't have an idle connection.</p>"},{"location":"user_guide/extras.html#helper_1","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: <code>None</code></p> </li> </ul>"},{"location":"user_guide/extras.html#example_1","title":"Example","text":"AsyncSync <pre><code>uri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\nawait db.close()\n</code></pre> <pre><code>uri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\ndb.close()\n</code></pre>"},{"location":"user_guide/extras.html#is_healthy","title":"is_healthy","text":""},{"location":"user_guide/extras.html#description_2","title":"Description","text":"<p>Check if the connection is healthy.</p> <p>Returns <code>false</code>, if connection is considered to not be in a working state.</p>"},{"location":"user_guide/extras.html#helper_2","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>bool</code></p> </li> <li> <p>Raises: <code>None</code></p> </li> </ul>"},{"location":"user_guide/extras.html#requires_isolation_first","title":"requires_isolation_first","text":""},{"location":"user_guide/extras.html#description_3","title":"Description","text":"<p>Returns <code>True</code> if the connection requires isolation first, <code>False</code> otherwise.</p> <p>This is used to determine if the connection should be isolated before executing a query.</p> <p>For example, SQL Server requires isolation before executing a statement using begin in some cases.</p> <p>Signals if the <code>isolation level</code> SET needs to happen before or after the <code>BEGIN</code>.</p>"},{"location":"user_guide/extras.html#helper_3","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>bool</code></p> </li> <li> <p>Raises: <code>None</code></p> </li> </ul>"},{"location":"user_guide/extras.html#extra-documentation","title":"Extra documentation:","text":"<ul> <li>MSSQL</li> <li>Postgres</li> <li>MySQL</li> <li>SQLite</li> </ul>"},{"location":"user_guide/extras.html#raw_cmd","title":"raw_cmd","text":""},{"location":"user_guide/extras.html#description_4","title":"Description","text":"<p>Run a command in the database, for queries that can't be run using prepared statements(queries/execute/etc).</p>"},{"location":"user_guide/extras.html#helper_4","title":"Helper","text":"<ul> <li> <p>Arguments: </p> <ul> <li><code>sql(str)</code>: sql to be executed.</li> </ul> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: <code>RawCmdError</code></p> </li> </ul>"},{"location":"user_guide/extras.html#example_2","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nawait db.raw_cmd(sql=\"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\")\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\ndb.raw_cmd(sql=\"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\")\n</code></pre>"},{"location":"user_guide/extras.html#query","title":"query","text":""},{"location":"user_guide/extras.html#description_5","title":"Description","text":"<p>Returns all rows from query result as <code>BaseRow list</code>, <code>MyModel list</code> or <code>empty list</code>.</p>"},{"location":"user_guide/extras.html#helper_5","title":"Helper","text":"<ul> <li> <p>Arguments:</p> <ul> <li> <p><code>sql(str)</code>: sql query to be executed.</p> </li> <li> <p><code>parameters(dict)</code>: (default is None) dictionary with the name of the parameter and the value.</p> </li> <li> <p><code>model(BaseRow)</code>: (default is None) is your model that inherits from BaseRow.</p> </li> </ul> </li> <li> <p>Returns:</p> <ul> <li> <p><code>List[BaseRow]</code>: default if you don't pass a model.</p> </li> <li> <p><code>List[MyModel]</code>: If you pass a model.</p> </li> <li> <p><code>List</code>: If don't have rows.</p> </li> </ul> </li> <li> <p>Raises: </p> <ul> <li><code>QueryError</code></li> <li><code>TypeError</code> </li> <li><code>ParameterInvalidProviderError</code></li> <li><code>ParameterInvalidValueError</code></li> <li><code>ParameterInvalidJsonValueError</code></li> </ul> </li> </ul> AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nresult1 = await db.query(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output: [BaseRow(id=1, name='rian')]\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = await db.query(sql=sql, parameters=param)\nprint(result2)\n# output: [BaseRow(id=1, name='rian')]\n\nawait db.close()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\nresult1 = db.query(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output: [BaseRow(id=1, name='rian')]\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = db.query(sql=sql, parameters=param)\nprint(result2)\n# output: [BaseRow(id=1, name='rian')]\n\ndb.close()\n</code></pre>"},{"location":"user_guide/extras.html#query_first","title":"query_first","text":""},{"location":"user_guide/extras.html#description_6","title":"Description","text":"<p>Returns first row from query result as <code>BaseRow</code>, <code>MyModel</code> or <code>None</code>.</p>"},{"location":"user_guide/extras.html#helper_6","title":"Helper","text":"<ul> <li> <p>Arguments:</p> <ul> <li> <p><code>sql(str)</code>: sql query to be executed.</p> </li> <li> <p><code>parameters(dict)</code>: (default is None) parameters must be a dictionary with the name of the parameter and the value.</p> </li> <li> <p><code>model(BaseRow)</code>: (default is None) is your model that inherits from BaseRow.</p> </li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>BaseRow</code>: default if you don't pass a model.</li> <li><code>MyModel</code>: If you pass a model.</li> <li><code>None</code>: if no rows are found.</li> </ul> </li> <li> <p>Raises: </p> <ul> <li><code>QueryError</code></li> <li><code>TypeError</code></li> <li><code>ParameterInvalidProviderError</code></li> <li><code>ParameterInvalidValueError</code></li> <li><code>ParameterInvalidJsonValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_3","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nresult1 = await db.query_first(\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; BaseRow(id=1, name='rian')\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = await db.query_first(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; BaseRow(id=1, name='rian')\n\nawait db.close()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\nresult1 = db.query_first(\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; BaseRow(id=1, name='rian')\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = await db.query_first(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; BaseRow(id=1, name='rian')\n\ndb.close()\n</code></pre>"},{"location":"user_guide/extras.html#query_as_dict","title":"query_as_dict","text":""},{"location":"user_guide/extras.html#description_7","title":"Description","text":"<p>Returns all rows from query result as <code>dict list</code> or <code>empty list</code>.</p>"},{"location":"user_guide/extras.html#helper_7","title":"Helper","text":"<ul> <li> <p>Arguments:</p> <ul> <li> <p><code>sql(str)</code>: sql query to be executed.</p> </li> <li> <p><code>parameters(dict)</code>: (default is None) dictionary with the name of the parameter and the value.</p> </li> </ul> </li> <li> <p>Returns:</p> <ul> <li> <p><code>List[Dict[str, Any]]</code>: dict list.</p> </li> <li> <p><code>List</code>: empty list.</p> </li> </ul> </li> <li> <p>Raises: </p> <ul> <li><code>QueryError</code></li> <li><code>TypeError</code></li> <li><code>ParameterInvalidProviderError</code></li> <li><code>ParameterInvalidValueError</code></li> <li><code>ParameterInvalidJsonValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_4","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nresult1 = await db.query_as_dict(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; [{'id': 1, 'name': 'rian'}]\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = await db.query_as_dict(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; [{'id': 1, 'name': 'rian'}]\n\nawait db.close()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\nresult1 = db.query_as_dict(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; [{'id': 1, 'name': 'rian'}]\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = db.query_as_dict(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; [{'id': 1, 'name': 'rian'}]\n\ndb.close()\n</code></pre>"},{"location":"user_guide/extras.html#query_first_as_dict","title":"query_first_as_dict","text":""},{"location":"user_guide/extras.html#description_8","title":"Description","text":"<p>Returns first row from query result as <code>dict</code> or <code>None</code>.</p>"},{"location":"user_guide/extras.html#helper_8","title":"Helper","text":"<ul> <li> <p>Arguments:</p> <ul> <li> <p><code>sql(str)</code>: sql query to be executed.</p> </li> <li> <p><code>parameters(dict)</code>: (default is None) parameters must be a dictionary with the name of the parameter and the value.</p> </li> </ul> </li> <li> <p>Returns:</p> <ul> <li> <p><code>Dict[str, Any]</code>: row as dict.</p> </li> <li> <p><code>None</code>: if no rows are found.</p> </li> </ul> </li> <li> <p>Raises: </p> <ul> <li><code>QueryError</code></li> <li><code>TypeError</code> </li> <li><code>ParameterInvalidProviderError</code></li> <li><code>ParameterInvalidValueError</code></li> <li><code>ParameterInvalidJsonValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_5","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nresult1 = await db.query_first_as_dict(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; {'id': 1, 'name': 'rian'}\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = await db.query_first_as_dict(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; {'id': 1, 'name': 'rian'}\n\nawait db.close()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\nresult1 = db.query_first_as_dict(sql=\"SELECT 1 as id, 'rian' as name\")\nprint(result1)\n# output -&gt; {'id': 1, 'name': 'rian'}\n\nsql = \"SELECT :id as id, :name as name\"\nparam = {\"id\": 1, \"name\": \"rian\"}\nresult2 = db.query_first_as_dict(sql=sql, parameters=param)\nprint(result2)\n# output -&gt; {'id': 1, 'name': 'rian'}\n\ndb.close()\n</code></pre>"},{"location":"user_guide/extras.html#execute","title":"execute","text":""},{"location":"user_guide/extras.html#description_9","title":"Description","text":"<p>Executes a query/sql and returns the number of rows affected.</p>"},{"location":"user_guide/extras.html#helper_9","title":"Helper","text":"<ul> <li> <p>Arguments:</p> <ul> <li> <p><code>sql(str)</code>:  sql to be executed.</p> </li> <li> <p><code>parameters(dict)</code>: (Default is None) dictionary with the name of the parameter and the value.</p> </li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>int</code>: number of rows affected.</li> </ul> </li> <li> <p>Raises: </p> <ul> <li><code>ExecuteError</code></li> <li><code>TypeError</code></li> <li><code>ParameterInvalidProviderError</code></li> <li><code>ParameterInvalidValueError</code></li> <li><code>ParameterInvalidJsonValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_6","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nresult = await db.execute(\"INSERT INTO users (name) VALUES ('rian')\")\nprint(f\"rows_affected = {result}\")\n# output -&gt; rows_affected = 1\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\nresult db.execute(\"INSERT INTO users (name) VALUES ('rian')\")\nprint(f\"rows_affected = {result}\")\n# output -&gt; rows_affected = 1\n</code></pre>"},{"location":"user_guide/extras.html#set_isolation_level","title":"set_isolation_level","text":""},{"location":"user_guide/extras.html#description_10","title":"Description","text":"<p>Sets the isolation level of the connection.</p> <p>The isolation level is set before the transaction is started. Is used to separate the transaction per level.</p> <p>The <code>Snapshot</code> isolation level is supported by MS SQL Server.</p> <p>The Sqlite does not support the isolation level.</p>"},{"location":"user_guide/extras.html#helper_10","title":"Helper","text":"<ul> <li> <p>Arguments: </p> <ul> <li><code>isolation_level(str)</code>: isolation level to be set (     <code>ReadUncommitted</code>,     <code>ReadCommitted</code>,     <code>RepeatableRead</code>,     <code>Snapshot</code>,     <code>Serializable</code>     )</li> </ul> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: </p> <ul> <li><code>IsolationLevelError</code></li> <li><code>ValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_7","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\nawait db.set_isolation_level(isolation_level=\"ReadUncommitted\")\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\ndb.set_isolation_level(isolation_level=\"ReadUncommitted\")\n</code></pre>"},{"location":"user_guide/extras.html#isolation-level-help","title":"Isolation Level Help","text":"<ul> <li>MSSQL</li> <li>Postgres</li> <li>MySQL</li> <li>SQLite</li> </ul>"},{"location":"user_guide/extras.html#begin","title":"begin","text":""},{"location":"user_guide/extras.html#description_11","title":"Description","text":"<p>Starts a transaction using <code>BEGIN</code>. <code>begin()</code> is equivalent to <code>start_transaction()</code> without setting the isolation level.</p>"},{"location":"user_guide/extras.html#helper_11","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: <code>RawCmdError</code></p> </li> </ul>"},{"location":"user_guide/extras.html#example_8","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\nawait db.begin()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\ndb.begin()\n</code></pre>"},{"location":"user_guide/extras.html#commit","title":"commit","text":""},{"location":"user_guide/extras.html#description_12","title":"Description","text":"<p>Commits the current transaction.</p> <p>The <code>begin()</code> method must be called before calling <code>commit()</code>.</p> <p>If the database not need set the isolation level, maybe you can not use <code>begin()</code> and <code>commit()</code>.</p> <p>The PySQLXEngine by default uses the <code>begin()</code> and <code>commit()</code> in all transactions.</p>"},{"location":"user_guide/extras.html#helper_12","title":"Helper","text":"<pre><code>* Arguments: ``None`\n\n* Returns: ``None``\n\n* Raises: ``RawCmdError``\n</code></pre>"},{"location":"user_guide/extras.html#example_9","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nawait db.begin()\nawait db.execute(\"CREATE TABLE users (id serial PRIMARY KEY, name varchar(255))\")\nawait db.execute(\"INSERT INTO users (name) VALUES ('rian')\")\nawait db.commit()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\ndb.begin()\ndb.execute(\"CREATE TABLE users (id serial PRIMARY KEY, name varchar(255))\")\ndb.execute(\"INSERT INTO users (name) VALUES ('rian')\")\ndb.commit()\n</code></pre>"},{"location":"user_guide/extras.html#rollback","title":"rollback","text":""},{"location":"user_guide/extras.html#description_13","title":"Description","text":"<p>Rollbacks the current transaction.</p> <p>Rollback is used to cancel the transaction, when you uses the rollback, the transaction is canceled and the changes are not saved.</p> <p>The <code>begin()</code> method must be called before calling <code>rollback()</code>.</p> <p>If the database not need set the isolation level, maybe you can not use <code>begin()</code> and <code>rollback()</code>.</p> <p>The PySQLXEngine by default try uses the <code>begin()</code> and <code>commit()</code> in all transactions.</p>"},{"location":"user_guide/extras.html#helper_13","title":"Helper","text":"<ul> <li> <p>Arguments: <code>None</code></p> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: <code>RawCmdError</code></p> </li> </ul>"},{"location":"user_guide/extras.html#example_10","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\nawait db.begin()\nawait db.execute(\"CREATE TABLE users (id serial PRIMARY KEY, name varchar(255))\")\nawait db.execute(\"INSERT INTO users (name) VALUES ('rian')\")\nawait db.rollback()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\ndb.begin()\ndb.execute(\"CREATE TABLE users (id serial PRIMARY KEY, name varchar(255))\")\ndb.execute(\"INSERT INTO users (name) VALUES ('rian')\")\ndb.rollback()\n</code></pre>"},{"location":"user_guide/extras.html#start_transaction","title":"start_transaction","text":""},{"location":"user_guide/extras.html#description_14","title":"Description","text":"<p>Starts a transaction with <code>BEGIN/BEGIN TRANSACTION</code>. by default, does not set the isolation level.</p> <p>The <code>Snapshot</code> isolation level is supported by MS SQL Server.</p> <p>The Sqlite does not support the isolation level.</p>"},{"location":"user_guide/extras.html#helper_14","title":"Helper","text":"<ul> <li> <p>Arguments: </p> <ul> <li><code>isolation_level(str)</code>: by default is None. Isolation level to be set ( <code>ReadUncommitted</code>, <code>ReadCommitted</code>, <code>RepeatableRead</code>, <code>Snapshot</code>, <code>Serializable</code> )</li> </ul> </li> <li> <p>Returns: <code>None</code></p> </li> <li> <p>Raises: </p> <ul> <li><code>IsolationLevelError</code></li> <li><code>StartTransactionError</code></li> <li><code>ValueError</code></li> </ul> </li> </ul>"},{"location":"user_guide/extras.html#example_11","title":"Example","text":"AsyncSync <pre><code>from pysqlx_engine import PySQLXEngine\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngine(uri=uri)\nawait db.connect()\n\n# with isolation level\nawait db.start_transaction(isolation_level=\"ReadCommitted\")\n\n# without isolation level\nawait db.start_transaction()\n</code></pre> <pre><code>from pysqlx_engine import PySQLXEngineSync\n\nuri = \"postgresql://user:pass@host:port/db?schema=sample\"\ndb = PySQLXEngineSync(uri=uri)\ndb.connect()\n\n# with isolation level\ndb.start_transaction(isolation_level=\"ReadCommitted\")\n\n# without isolation level\ndb.start_transaction()\n</code></pre>"},{"location":"user_guide/extras.html#isolation-level-help_1","title":"Isolation Level Help","text":"<ul> <li>MSSQL</li> <li>Postgres</li> <li>MySQL</li> <li>SQLite</li> </ul>"},{"location":"user_guide/parameters.html","title":"Parameters","text":""},{"location":"user_guide/parameters.html#parameters","title":"Parameters","text":"<p>The PySQLX-Engine supports the parameters. The parameters are passed as a dictionary to the functions below.</p> <ul> <li><code>query</code></li> <li><code>query_first</code></li> <li><code>query_as_dict</code></li> <li><code>query_first_as_dict</code></li> <li><code>execute</code></li> </ul> <p>These functions are described in the Documentation for methods section.</p> <p>Parameters are has prepared statements, where the values are converted to rust types and then to SQL types.</p> <p>Python types &gt; Rust types &gt; SQL types</p> <p>Note</p> <p>In development mode, the SQL statements are printed in the console with the parameters builded and raw SQL. But the SQL builded with the parameters is not sent to the database.</p> <p>The PySQLXEngine supports many Python types with automatic conversion to SQL.</p>"},{"location":"user_guide/parameters.html#parameters-types","title":"Parameters types","text":"<p>Key: dict <code>key</code> must be a valid string.</p> <p>Value: dict <code>value</code> can be one of the types bellow:</p> <ul> <li><code>bool</code></li> <li><code>bytes</code></li> <li><code>date</code></li> <li><code>datetime</code></li> <li><code>Decimal</code></li> <li><code>dict</code></li> <li><code>float</code></li> <li><code>int</code></li> <li><code>list</code></li> <li><code>str</code></li> <li><code>time</code></li> <li><code>tuple</code></li> <li><code>UUID</code></li> <li><code>enum.Enum</code></li> <li><code>None</code></li> </ul> <p>These types are converted to the corresponding SQL type. This applies to parameters chained in a list or dict that are converted to json.</p>"},{"location":"user_guide/parameters.html#example","title":"Example","text":"<p>For this example, the table <code>users</code> will be used. The table <code>users</code> has the following structure:</p> <pre><code>CREATE TABLE IF NOT EXISTS users (\n    id INTEGER, \n    name TEXT, \n    age INTEGER,\n    active BOOLEAN\n);\n</code></pre> <p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    db = PySQLXEngine(uri=\"sqlite:./db.db\")\n    await db.connect()\n\n    param = {\n        \"i\": 1,\n        \"n\": \"John\",\n        \"ag\": 20,\n        \"ac\": True\n    }\n    sql = \"\"\"\n        INSERT INTO users (id, name, age, active) \n        VALUES (:i, :n, :ag, :ac);\n    \"\"\"\n\n    resp = await db.execute(sql=sql, parameters=param)\n\n    print(\"inserted: \", resp == 1)\n\nimport asyncio\nasyncio.run(main())    \n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    db = PySQLXEngineSync(uri=\"postgresql://user:pass@host:port/db\")\n    db.connect()\n\n    param = {\n        \"i\": 1,\n        \"n\": \"John\",\n        \"ag\": 20,\n        \"ac\": True\n    }\n    sql = \"\"\"\n        INSERT INTO users (id, name, age, active) \n        VALUES (:i, :n, :ag, :ac);\n    \"\"\"\n\n    resp = db.execute(sql=sql, parameters=param)\n\n    print(\"inserted: \", resp == 1)\n\n# runnig the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\ninserted: True\n</code></pre>"},{"location":"user_guide/queries.html","title":"Queries","text":""},{"location":"user_guide/queries.html#queries","title":"Queries","text":"<p>The PySQLXEngine has four methods to execute queries:</p> <ul> <li><code>.query()</code>: Returns all rows of the query. The results are returned as a list of BaseRow.</li> <li><code>.query_first()</code>: Returns the first row of the query. The result is returned as a BaseRow.</li> <li><code>.query_as_dict()</code>: Returns all rows of the query. The results are returned as a list of dict.</li> <li><code>.query_first_as_dict()</code>: Returns the first row of the query. The result is returned as a dict.</li> </ul> <p>You can use the same methods for both <code>sync</code> and <code>async</code>. All the methods accept the <code>sql</code> and <code>parameters</code> arguments.</p> <p>Create a <code>main.py</code> file and add the code examples below.</p>"},{"location":"user_guide/queries.html#query-result-as-dict","title":"Query result as dict","text":"<p>The <code>.query_as_dict()</code> and <code>.query_first_as_dict()</code> methods are useful when you want to get the results as a <code>list of dict</code> or a <code>dict</code>.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = await db.query_as_dict(sql=sql)\n    resp2 = await db.query_first_as_dict(sql=sql)\n\n    print(\"returned:\", resp1, \"as a list of dicts\")\n    print(\"returned:\", resp2, \"as a dict\")\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = db.query_as_dict(sql=sql)\n    resp2 = db.query_first_as_dict(sql=sql)\n\n    print(\"returned:\", resp1, \"as a list of dicts\")\n    print(\"returned:\", resp2, \"as a dict\")\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nreturned: [{'id': 1, 'name': 'Rian'}] as a list of dict \nreturned: {'id': 1, 'name': 'Rian'} as a dict\n</code></pre>"},{"location":"user_guide/queries.html#query-result-as-baserow","title":"Query result as BaseRow","text":"<p>The <code>.query()</code> and <code>.query_first()</code> methods are useful when you want to get the results as a <code>list of BaseRow</code> or a <code>BaseRow</code>.</p> <p>BaseRow is a class that represents a row of the query result. It has the same attributes as the columns of the query result.  The BaseRow is an inheritance from <code>Pydantic BaseModel</code>.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = await db.query(sql=sql)\n    resp2 = await db.query_first(sql=sql)\n\n    print(\"returned:\", resp1, \"as a list of BaseRow\")\n    print(\"returned:\", resp2, \"as a BaseRow\")\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = db.query(sql=sql)\n    resp2 = db.query_first(sql=sql)\n\n    print(\"returned:\", resp1, \"as a list of BaseRow\")\n    print(\"returned:\", resp2, \"as a BaseRow\")\n\n# running the code\nmain()\n</code></pre> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nreturned: [BaseRow(id=1, name='Rian')] as a list of BaseRow\nreturned: BaseRow(id=1, name='Rian') as a BaseRow\n</code></pre>"},{"location":"user_guide/queries.html#query-result-as-mymodel","title":"Query result as MyModel","text":"<p>The <code>.query()</code> and <code>.query_first()</code> methods are useful when you want to get the results as a <code>list of MyModel</code> or a <code>MyModel</code>.</p> <p>The PySQLXEngine has a feature to convert the query result to a custom model. You can use the <code>model</code> argument to specify the model.</p> <p>Using the <code>model</code> argument, you can have an autocomplete feature in your IDE, this brings more security and makes development easier.</p> <p>None</p> <p>The <code>model</code> argument is only available for the <code>.query()</code> and <code>.query_first()</code> methods. The <code>model</code> needs to inherit from <code>BaseRow</code>, you can use <code>from pysqlx_engine import BaseRow</code> to import the <code>BaseRow</code> class.</p> <p>Create a <code>models.py</code> file and add the code examples below.</p> models.py<pre><code>from pysqlx_engine import BaseRow\n\nclass User(BaseRow):\n    id: int\n    name: str\n</code></pre> <p>Create a <code>main.py</code> file and add the code examples below.</p> AsyncSync main.py<pre><code>from pysqlx_engine import PySQLXEngine\nfrom models import User\n\nasync def main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngine(uri=uri)\n    await db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = await db.query(sql=sql, model=User)\n    resp2 = await db.query_first(sql=sql, model=User)\n\n    print(\"returned:\", resp1, \"as a list of User\")\n    print(\"returned:\", resp2, \"as a User\")\n\nimport asyncio\nasyncio.run(main())\n</code></pre> main.py<pre><code>from pysqlx_engine import PySQLXEngineSync\nfrom models import User\n\ndef main():\n    uri = \"sqlite:./db.db\"\n    db = PySQLXEngineSync(uri=uri)\n    db.connect()\n\n    sql = \"SELECT 1 AS id, 'Rian' AS name\"\n\n    resp1 = db.query(sql=sql, model=User)\n    resp2 = db.query_first(sql=sql, model=User)\n\n    print(\"returned:\", resp1, \"as a list of User\")\n    print(\"returned:\", resp2, \"as a User\")\n\n# running the code\nmain()\n</code></pre> <p>You can see the autocomple.</p> <p>Visual Studio Code</p> <p></p> <p>PyCharm</p> <p></p> <p>Running the code using the terminal</p> <pre><code>$ python3 main.py\n\nreturned: [User(id=1, name='Rian')] as a list of User\nreturned: User(id=1, name='Rian') as a User\n</code></pre>"},{"location":"user_guide/uri_mysql.html","title":"MySQL","text":""},{"location":"user_guide/uri_mysql.html#database-uri","title":"Database URI","text":""},{"location":"user_guide/uri_mysql.html#mysql","title":"MySQL","text":"<p>Here's an overview of the components needed for a MySQL connection URL:</p> <p></p>"},{"location":"user_guide/uri_mysql.html#base-url-and-path","title":"Base URL and path","text":"<p>Here is an example of the structure of the base URL and the path using placeholder values in uppercase letters:</p> <pre><code>mysql://USER:PASSWORD@HOST:PORT/DATABASE\n</code></pre> <p>The following components make up the base URL of your database, they are always required:</p> Name Placeholder Description Host <code>HOST</code> IP address/domain of your database server, e.g. localhost Port <code>PORT</code> Port on which your database server is running, e.g. 5432 User <code>USER</code> Name of your database user, e.g. janedoe Password <code>PASSWORD</code> Password for your database user Database <code>DATABASE</code> Name of the database you want to use, e.g. mydb"},{"location":"user_guide/uri_mysql.html#arguments","title":"Arguments","text":"<p>A connection URL can also take arguments. Here is the same example from above with placeholder values in uppercase letters for three arguments:</p> <pre><code>mysql://USER:PASSWORD@HOST:PORT/DATABASE?KEY1=VALUE&amp;KEY2=VALUE&amp;KEY3=VALUE\n</code></pre> <p>Sintax:</p> <ul> <li>Example: <code>KEY1</code>=<code>VALUE</code>&amp;<code>KEY2</code>=<code>VALUE</code></li> <li>Equal sign <code>=</code> is used to separate the <code>key</code> from the <code>value</code></li> <li>Ampersand <code>&amp;</code> is used to separate the arguments</li> </ul> Argument name Required Default Description connect_timeout No 5 Maximum number of seconds to wait for a new connection to be opened, 0 means no timeout sslcert No Path to the server certificate. sslidentity No Path to the PKCS12 certificate sslpassword No Password that was used to secure the PKCS12 file sslaccept No accept_invalid_certs Configures whether to check for missing values in the certificate. Possible values: accept_invalid_certs, strict socket No Points to a directory that contains a socket to be used for the connection socket_timeout No Number of seconds to wait until a single query terminates"},{"location":"user_guide/uri_mysql.html#configuring-an-ssl-connection","title":"Configuring an SSL connection","text":"<p>You can add various parameters to the connection URL if your database server uses SSL. Here's an overview of the possible parameters:</p> <ul> <li> <p><code>sslcert=&lt;PATH&gt;</code>: Path to the server certificate. This is the root certificate used by the database server to sign the client certificate. You need to provide this if the certificate doesn't exist in the trusted certificate store of your system. For Google Cloud this likely is server-ca.pem.</p> </li> <li> <p><code>sslidentity=&lt;PATH&gt;</code>: Path to the PKCS12 certificate database created from client cert and key. This is the SSL identity file in PKCS12 format which you will generate using the client key and client certificate. It combines these two files in a single file and secures them via a password (see next parameter). You can create this file using your client key and client certificate by using the following command (using <code>openssl</code>):</p> </li> </ul> <pre><code>openssl pkcs12 -export \\\n    -out client-identity.p12 \\\n    -inkey client-key.pem \\\n    -in client-cert.pem\n</code></pre> <ul> <li> <p><code>sslpassword=&lt;PASSWORD&gt;</code>: Password that was used to secure the PKCS12 file. The openssl command listed in the previous step will ask for a password while creating the PKCS12 file, you will need to provide that same exact password here.</p> </li> <li> <p><code>sslaccept=(strict|accept_invalid_certs)</code>:</p> <ul> <li> <p><code>strict</code>: Any missing value in the certificate will lead to an error. For Google Cloud, especially if the database doesn't have a domain name, the certificate might miss the domain/IP address, causing an error when connecting.</p> </li> <li> <p><code>accept_invalid_certs (default)</code>: Bypass this check. Be aware of the security consequences of this setting.</p> </li> </ul> </li> </ul> <p>Your database connection URL will look similar to this:</p> <pre><code>mysql://USER:PASSWORD@HOST:PORT/DATABASE?sslidentity=client-identity.p12&amp;sslpassword=mypassword&amp;sslcert=rootca.cert\n</code></pre>"},{"location":"user_guide/uri_mysql.html#connecting-via-sockets","title":"Connecting via sockets","text":"<p>To connect to your MySQL database via sockets, you must add a socket field as a query parameter to the connection URL (instead of setting it as the host part of the URI). The value of this parameter then must point to the directory that contains the socket, e.g.: <code>mysql://USER:POST@localhost/database?socket=/var/run/mysql/</code></p> <p>Note that localhost is required, the value itself is ignored and can be anything.</p>"},{"location":"user_guide/uri_postgresql.html","title":"PostgreSQL","text":""},{"location":"user_guide/uri_postgresql.html#database-uri","title":"Database URI","text":""},{"location":"user_guide/uri_postgresql.html#postgresql","title":"PostgreSQL","text":"<p>PySQLXEngine is based on the official PostgreSQL format for connection URLs, but does not support all arguments and includes additional arguments such as schema. Here's an overview of the components needed for a PostgreSQL connection URL:</p> <p></p>"},{"location":"user_guide/uri_postgresql.html#base-url-and-path","title":"Base URL and path","text":"<p>Here is an example of the structure of the base URL and the path using placeholder values in uppercase letters:</p> <pre><code>postgresql://USER:PASSWORD@HOST:PORT/DATABASE\n</code></pre> <p>The following components make up the base URL of your database, they are always required:</p> Name Placeholder Description Host <code>HOST</code> IP address/domain of your database server, e.g.\u00a0localhost Port <code>PORT</code> Port on which your database server is running, e.g.\u00a05432 User <code>USER</code> Name of your database user, e.g.\u00a0janedoe Password <code>PASSWORD</code> Password for your database user Database <code>DATABASE</code> Name of the\u00a0database\u00a0you want to use, e.g.\u00a0mydb"},{"location":"user_guide/uri_postgresql.html#arguments","title":"Arguments","text":"<p>A connection URL can also take arguments. Here is the same example from above with placeholder values in uppercase letters for three arguments:</p> <pre><code>postgresql://USER:PASSWORD@HOST:PORT/DATABASE?KEY1=VALUE&amp;KEY2=VALUE&amp;KEY3=VALUE\n</code></pre> <p>Sintax:</p> <ul> <li>Example: <code>KEY1</code>=<code>VALUE</code>&amp;<code>KEY2</code>=<code>VALUE</code></li> <li>Equal sign <code>=</code> is used to separate the <code>key</code> from the <code>value</code></li> <li>Ampersand <code>&amp;</code> is used to separate the arguments</li> </ul> <p>The following arguments can be used:</p> Argument name Required Default Description schema Yes public Name of the\u00a0schema\u00a0you want to use, e.g.\u00a0myschema connect_timeout No 5 Maximum number of seconds to wait for a new connection to be opened,\u00a00\u00a0means no timeout sslmode No prefer Configures whether to use TLS. Possible values:\u00a0prefer,\u00a0disable,\u00a0require sslcert No Path of the server certificate sslidentity No Path to the PKCS12 certificate sslpassword No Password that was used to secure the PKCS12 file sslaccept No accept_invalid_certs Configures whether to check for missing values in the certificate. Possible values:\u00a0accept_invalid_certs,\u00a0strict host No Points to a directory that contains a socket to be used for the connection socket_timeout No Maximum number of seconds to wait until a single query terminates application_name No Since 3.3.0: Specifies a value for the application_name configuration parameter channel_binding No prefer Since 4.8.0: Specifies a value for the channel_binding configuration parameter options No Since 3.8.0: Specifies command line options to send to the server at connection start"},{"location":"user_guide/uri_postgresql.html#configuring-an-ssl-connection","title":"Configuring an SSL connection","text":"<p>You can add various parameters to the connection URL if your database server uses SSL. Here's an overview of the possible parameters:</p> <ul> <li> <p><code>sslmode=(disable|prefer|require)</code>:</p> <ul> <li><code>prefer</code> (default): Prefer TLS if possible, accept plain text connections.</li> <li><code>disable</code>: Do not use TLS.</li> <li><code>require</code>: Require TLS or fail if not possible.</li> </ul> </li> <li> <p><code>sslcert=&lt;PATH&gt;</code>: Path to the server certificate. This is the root certificate used by the database server to sign the client certificate. You need to provide this if the certificate doesn't exist in the trusted certificate store of your system. For Google Cloud this likely is server-ca.pem.</p> </li> <li> <p><code>sslidentity=&lt;PATH&gt;</code>: Path to the PKCS12 certificate database created from client cert and key. This is the SSL identity file in PKCS12 format which you will generate using the client key and client certificate. It combines these two files in a single file and secures them via a password (see next parameter). You can create this file using your client key and client certificate by using the following command (using <code>openssl</code>):</p> </li> </ul> <pre><code>openssl pkcs12 -export \\\n    -out client-identity.p12 \\\n    -inkey client-key.pem \\\n    -in client-cert.pem\n</code></pre> <ul> <li> <p><code>sslpassword=&lt;PASSWORD&gt;</code>: Password that was used to secure the PKCS12 file. The openssl command listed in the previous step will ask for a password while creating the PKCS12 file, you will need to provide that same exact password here.</p> </li> <li> <p><code>sslaccept=(strict|accept_invalid_certs)</code>:</p> <ul> <li>strict: Any missing value in the certificate will lead to an error. For Google Cloud, especially if the database doesn't have a domain name, the certificate might miss the domain/IP address, causing an error when connecting.</li> <li>accept_invalid_certs (default): Bypass this check. Be aware of the security consequences of this setting.</li> </ul> </li> </ul> <p>Your database connection URL will look similar to this:</p> <pre><code>postgresql://USER:PASSWORD@HOST:PORT/DATABASE?sslidentity=client-identity.p12&amp;sslpassword=mypassword&amp;sslcert=rootca.cert\n</code></pre>"},{"location":"user_guide/uri_postgresql.html#connecting-via-sockets","title":"Connecting via sockets","text":"<p>To connect to your PostgreSQL database via sockets, you must add a host field as a query parameter to the connection URL (instead of setting it as the host part of the URI). The value of this parameter then must point to the directory that contains the socket, e.g.: <code>postgresql://USER:PASSWORD@localhost/database?host=/var/run/postgresql/</code></p> <p>Note that localhost is required, the value itself is ignored and can be anything.</p>"},{"location":"user_guide/uri_sqlite.html","title":"SQLite","text":""},{"location":"user_guide/uri_sqlite.html#database-uri","title":"Database URI","text":""},{"location":"user_guide/uri_sqlite.html#sqlite","title":"SQLite","text":""},{"location":"user_guide/uri_sqlite.html#connection-url","title":"Connection URL","text":"<p>The connection URL of a SQLite connector points to a file on your file system. For example, the following two paths are equivalent because the .db is in the same directory:</p> <p>Example 1:</p> <pre><code>sqlite:./dev.db\n</code></pre> <p>Example 2:</p> <pre><code>sqlite:dev.db\n</code></pre> <p>Example 3:</p> <pre><code>sqlite:/Users/janedoe/dev.db\n</code></pre>"},{"location":"user_guide/sqlserver/index.html","title":"Microsoft SQL Server","text":""},{"location":"user_guide/sqlserver/index.html#microsoft-sql-server","title":"Microsoft SQL Server","text":""},{"location":"user_guide/sqlserver/index.html#microsoft-sql-server_1","title":"Microsoft SQL Server","text":""},{"location":"user_guide/sqlserver/index.html#connection-details","title":"Connection details","text":"<p>The connection URL used to connect to an Microsoft SQL Server database follows the JDBC standard.</p> <p>The following example uses SQL authentication (username and password) with an enabled TLS encrypted connection:</p> <pre><code>sqlserver://HOST:PORT;database=DATABASE;user=USER;password=PASSWORD;encrypt=true;\n</code></pre>"},{"location":"user_guide/sqlserver/index.html#using-integrated-security-windows-only","title":"Using integrated security (Windows only)","text":"<p>The following example uses the currently logged in Windows user to log in to Microsoft SQL Server:</p> <pre><code>sqlserver://localhost:1433;initialCatalog=sample;integratedSecurity=true;trustServerCertificate=true;\n</code></pre> <p>The following example uses a specific Active Directory user to log in to Microsoft SQL Server:</p> <pre><code>sqlserver://localhost:1433;initialCatalog=sample;integratedSecurity=true;username=pysqlx;password=aBcD1234;trustServerCertificate=true;\n</code></pre>"},{"location":"user_guide/sqlserver/index.html#using-sql-browser-to-connect-to-a-named-instance","title":"Using SQL Browser to connect to a named instance","text":"<p>The following example connects to a named instance of Microsoft SQL Server (mycomputer\\sql2019) using integrated security:</p> <pre><code>sqlserver://mycomputer\\sql2019;initialCatalog=sample;integratedSecurity=true;trustServerCertificate=true;\n</code></pre>"},{"location":"user_guide/sqlserver/index.html#arguments","title":"Arguments","text":"Argument   name Required Default Comments database/initial   catalog No master The database to   connect to. username/user/uid/userid No - see Comments SQL Server login (such   as sa) or a valid Windows (Active   Directory) username if integratedSecurity is set to true (Windows only). password/pwd No - see Comments Password for SQL   Server login or Windows   (Active Directory) username if integratedSecurity is set to true (Windows only). encrypt No true Configures whether to   use TLS all the time, or only for the login procedure, possible values: true (use always), false (only for login   credentials). integratedSecurity No Enables Windows   authentication (integrated security), possible values: true, false, yes, no. If set to true or yes and username and password are present, login is performed through Windows Active Directory. connectTimeout No 5 Maximum number of   seconds to wait for a new connection schema No dbo Added as a prefix to   all the queries if schema name is not the default. loginTimeout/connectTimeout/connectionTimeout No Number of seconds to   wait for login to succeed. socketTimeout No Number of seconds to   wait for each query to succeed. isolationLevel No Sets transaction isolation   level. ApplicationName/Application   Name(case insensitive) No Sets the application   name for the connection. Since version 2.28.0. trustServerCertificate No false Configures whether to   trust the server certificate. trustServerCertificateCA No A   path to a certificate authority file to be used instead of the system   certificates to authorize the server certificate. Must be either in pem, crt or der format. Cannot be used together with trustServerCertificate parameter."},{"location":"user_guide/sqlserver/uri_sqlserver_docker.html","title":"Microsoft SQL Server on Docker","text":""},{"location":"user_guide/sqlserver/uri_sqlserver_docker.html#microsoft-sql-server-on-docker","title":"Microsoft SQL Server on Docker","text":""},{"location":"user_guide/sqlserver/uri_sqlserver_docker.html#sql-server-on-docker","title":"SQL Server on Docker","text":"<p>To run a Microsoft SQL Server container image with Docker:</p> <ol> <li> <p>Install and set up Docker</p> </li> <li> <p>Run the following command in your terminal to download the Microsoft SQL Server 2019 image:</p> </li> </ol> <pre><code>$ docker pull mcr.microsoft.com/mssql/server:2019-latest\n\n...\n</code></pre> <ol> <li>Create an instance of the container image, replacing the value of SA_PASSWORD with a password of your choice:</li> </ol> <pre><code>$ docker run --name sql_container -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=myPassword' -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest\n\n...\n</code></pre> <ol> <li> <p>Follow Microsoft's instructions to connect to SQL Server and use the <code>sqlcmd</code> tool, replacing the image name and password with your own.</p> </li> <li> <p>From the <code>sqlcmd</code> command prompt, create a new database:</p> </li> </ol> <pre><code>CREATE DATABASE quickstart\nGO\n\n...\n</code></pre> <ol> <li>Run the following command to check that your database was created successfully:</li> </ol> <pre><code>sp_databases\nGO\n\n...\n</code></pre>"},{"location":"user_guide/sqlserver/uri_sqlserver_docker.html#connection-url-credentials","title":"Connection URL credentials","text":"<p>Based on this example, your credentials are:</p> <ul> <li>Username: <code>sa</code></li> <li>Password: <code>myPassword</code></li> <li>Database: <code>quickstart</code></li> <li>Port: <code>1433</code></li> </ul>"},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html","title":"Microsoft SQL Server Windows (Local)","text":""},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html#microsoft-sql-server-windows-local","title":"Microsoft SQL Server Windows (Local)","text":""},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html#sql-server-management-studio","title":"SQL Server Management Studio","text":"<p>To run a Microsoft SQL Server locally on a Windows machine:</p> <ol> <li> <p>If you do not have access to an instance of Microsoft SQL Server, download and set up SQL Server 2019 Developer.</p> </li> <li> <p>Download and install SQL Server Management Studio.</p> </li> <li> <p>Use Windows Authentication to log in to Microsoft SQL Server Management Studio (expand the Server Name dropdown and click  to find your database engine):</p> </li> </ol> <p></p>"},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html#enable-tcpip","title":"Enable TCP/IP","text":"<p>PySQLXEngine uses TCP/IP to connect to Microsoft SQL Server. To enable TCP/IP:</p> <ol> <li> <p>Open SQL Server Configuration Manager. (Search for \"SQL Server Configuration Manager\" in the Start Menu, or open the Start Menu and type \"SQL Server Configuration Manager\".)</p> </li> <li> <p>In the left-hand panel, click SQL Server Network Configuration &gt; Protocols for MSSQLSERVER.</p> </li> <li> <p>Right-click TCP/IP and choose Enable.</p> </li> </ol>"},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html#enable-authentication-with-sql-logins-optional","title":"Enable authentication with SQL logins (Optional)","text":"<p>If you want to use a username and password in your connection URL rather than integrated security, enable mixed authentication mode as follows:</p> <ol> <li> <p>Right-click on your database engine in the Object Explorer and click Properties.</p> </li> <li> <p>In the Server Properties window, click Security in the left-hand list and tick the SQL Server and Windows Authentication Mode option, then click OK.</p> </li> <li> <p>Right-click on your database engine in the Object Explorer and click Restart.</p> </li> </ol>"},{"location":"user_guide/sqlserver/uri_sqlserver_windows.html#enable-the-sa-login","title":"Enable the <code>sa</code> login","text":"<p>To enable the default sa (administrator) SQL Server login:</p> <ol> <li> <p>In SQL Server Management Studio, in the Object Explorer, expand Security &gt; Logins and double-click sa.</p> </li> <li> <p>On the General page, choose a password for the sa account (untick Enforce password policy if you do not want to enforce a policy).</p> </li> <li> <p>On the Status page, under Settings &gt; Login, tick Enabled, then click OK.</p> </li> </ol> <p>You can now use the <code>sa</code> account in a connection URL and when you log in to SQL Server Management Studio.</p> <p>Note</p> <p>Note: The sa user has extensive permissions. You can also create your own login with fewer permissions.</p>"}]}